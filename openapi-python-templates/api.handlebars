# flake8: noqa E501
import json
from asyncio import get_event_loop
from typing import Any, Awaitable, Dict, IO, List, TYPE_CHECKING
from datetime import date, datetime, timedelta
from uuid import UUID

from fastapi.encoders import jsonable_encoder

from @IMPORT_NAME@ import models as m

if TYPE_CHECKING:
    from @IMPORT_NAME@.api_client import ApiClient


{{#operations}}
class _{{classname}}:
    def __init__(self, api_client: "ApiClient"):
        self.api_client = api_client

{{#operation}}
    def _build_for_{{operationId}}(self, 
    {{#allParams}}
    
    {{#required}}{{paramName}}: {{>_dataTypeApi}}{{/required}}{{^required}}
    {{paramName}}: {{>_dataTypeApi}} = None{{/required}}{{^last}}, 
    {{/last}}

    {{{dataType}}}

    {{#isArray}}
            {{#items}}
                {{#isPrimitiveType}}
    :type {{paramName}}: List[{{>param_type}}]
                {{/isPrimitiveType}}
                {{^isPrimitiveType}}
    :type {{paramName}}: list | bytes
                {{/isPrimitiveType}}
            {{/items}}
        {{/isArray}}

        {{#isMap}}
            {{#items}}
                {{#isPrimitiveType}}
    :type {{paramName}}: Dict[str, {{>param_type}}]
                {{/isPrimitiveType}}
                {{^isPrimitiveType}}
    :type {{paramName}}: dict | bytes
                {{/isPrimitiveType}}
            {{/items}}
        {{/isMap}}
    
    {{/allParams}}
) -> Awaitable[{{>_returnType}}]:
{{#notes}}
        """
        {{{notes}}}
        """
{{/notes}}
{{#with composedSchemas}}
{{#if oneOf}}

@classmethod
@functools.lru_cache()
def one_of(cls):
    # we need this here to make our import statements work
    # we must store _composed_schemas in here so the code is only run
    # when we invoke this method. If we kept this at the class
    # level we would get an error because the class level
    # code would be run when this module is imported, and these composed
    # classes don't exist yet because their module has not finished
    # loading
    return [
{{#each oneOf}}
{{#if complexType}}
        {{complexType}},
{{else}}
    {{#if nameInSnakeCase}}
        cls.{{name}},
    {{else}}
        cls.{{baseName}},
    {{/if}}
{{/if}}
{{/each}}
    ]
{{/if}}
{{/with}}


{{#pathParams.0}}
        path_params = {
{{#pathParams}}
{{#required}}
            "{{baseName}}": str({{paramName}}){{^last}},{{/last}}
{{/required}}
{{/pathParams}}
        }
{{#pathParams}}
{{^required}}
        if {{paramName}} is not None:
            path_params["{{baseName}}"] = str({{paramName}})
{{/required}}
{{/pathParams}}

{{/pathParams.0}}
{{#queryParams.0}}
        query_params = {
{{#queryParams}}
{{#required}}
            "{{baseName}}": str({{paramName}}){{^last}},{{/last}}
{{/required}}
{{/queryParams}}
        }
{{#queryParams}}
{{^required}}
        if {{paramName}} is not None:
            query_params["{{baseName}}"] = {{#isArray}}[str({{paramName}}_item) for {{paramName}}_item in {{paramName}}]{{/isArray}}{{^isArray}}str({{paramName}}){{/isArray}}
{{/required}}
{{/queryParams}}

{{/queryParams.0}}
{{#headerParams.0}}
        headers = {
{{#headerParams}}
{{#required}}
            "{{baseName}}": str({{paramName}})
{{/required}}
{{/headerParams}}
        }
{{#headerParams}}
{{^required}}
        if {{paramName}} is not None:
            headers["{{baseName}}"] = str({{paramName}})
{{/required}}
{{/headerParams}}

{{/headerParams.0}}
{{#cookieParams.0}}
        cookies = {
{{#cookieParams}}
{{#required}}
            "{{baseName}}": str({{paramName}})
{{/required}}
{{/cookieParams}}
        }
{{#cookieParams}}
{{^required}}
        if {{paramName}} is not None:
            cookies["{{baseName}}"] = str({{paramName}})
{{/required}}
{{/cookieParams}}

{{/cookieParams.0}}
{{#formParams.0}}
        files: Dict[str, IO[Any]] = {}  # noqa F841
        data: Dict[str, Any] = {}  # noqa F841
{{#formParams}}
{{#required}}
        {{#isFile}}files{{/isFile}}{{^isFile}}data{{/isFile}}["{{baseName}}"] = {{paramName}}
{{/required}}
{{/formParams}}
{{#formParams}}
{{^required}}
        if {{paramName}} is not None:
            {{#isFile}}files{{/isFile}}{{^isFile}}data{{/isFile}}["{{baseName}}"] = {{paramName}}
{{/required}}
{{/formParams}}

{{/formParams.0}}
{{#bodyParam}}
        body = jsonable_encoder({{paramName}})

{{/bodyParam}}
        return self.api_client.request(
            type_={{>_returnType}},
            method="{{httpMethod}}",
            url="{{{path}}}",
            {{#pathParams.0}}path_params=path_params,{{/pathParams.0}}
            {{#queryParams.0}}params=query_params,{{/queryParams.0}}
            {{#headerParams.0}}headers=headers,{{/headerParams.0}}
            {{#cookieParams.0}}cookies=cookies,{{/cookieParams.0}}
            {{#formParams.0}}data=data,
            files=files{{^isMultipart}} or None{{/isMultipart}}{{/formParams.0}}
            {{#bodyParam}}json=body{{/bodyParam}}
        )

{{/operation}}
{{/operations}}

{{#operations}}
class Async{{classname}}(_{{classname}}):
{{#operation}}
    async def {{operationId}}(self, {{#allParams}}{{#required}}{{paramName}}: {{>_dataTypeApi}}{{/required}}{{^required}}{{paramName}}: {{>_dataTypeApi}} = None{{/required}}{{^last}}, {{/last}}{{/allParams}}) -> {{>_returnType}}:
{{#notes}}
        """
        {{{notes}}}
        """
{{/notes}}
        return await self._build_for_{{operationId}}({{#allParams}}{{paramName}}={{paramName}}{{^last}}, {{/last}}{{/allParams}})

{{/operation}}
{{/operations}}

{{#operations}}
class Sync{{classname}}(_{{classname}}):
{{#operation}}
    def {{operationId}}(self, {{#allParams}}{{#required}}{{paramName}}: {{>_dataTypeApi}}{{/required}}{{^required}}{{paramName}}: {{>_dataTypeApi}} = None{{/required}}{{^last}}, {{/last}}{{/allParams}}) -> {{>_returnType}}:
{{#notes}}
        """
        {{{notes}}}
        """
{{/notes}}
        coroutine = self._build_for_{{operationId}}({{#allParams}}{{paramName}}={{paramName}}{{^last}}, {{/last}}{{/allParams}})
        return get_event_loop().run_until_complete(coroutine)
{{/operation}}
{{/operations}}
